// Code generated by tensorgen. DO NOT EDIT.

package runners

import (
	"context"
	"errors"
	"fmt"

	tf "github.com/tensorflow/tensorflow/tensorflow/go"
	typespb "github.com/tensorflow/tensorflow/tensorflow/go/core/framework/types_go_proto"
)

const (
	signatureRequestPropsCount  = 4
	signatureResponsePropsCount = 1
)

type SignatureRequest struct {
	// msg_created_at DT_INT64 Shape:()
	MsgCreatedAt int64
	// msg_text DT_STRING Shape:()
	MsgText string
	// user_created_at DT_INT64 Shape:()
	UserCreatedAt int64
	// user_email DT_STRING Shape:()
	UserEmail string
}

type SignatureResponse struct {
	// confidence DT_FLOAT Shape:()
	Confidence float32
}

type SignatureRunner struct {
	graph   *tf.Graph
	session *tf.Session

	inputPlaceholders  [signatureRequestPropsCount]tf.Output
	outputPlaceholders [signatureResponsePropsCount]tf.Output
}

func NewSignatureRunner(graph *tf.Graph, session *tf.Session) *SignatureRunner {
	return &SignatureRunner{
		graph:   graph,
		session: session,
	}
}

func (r *SignatureRunner) LoadOperations() error {
	type description struct {
		Name    string
		Type    typespb.DataType
		OpName  string
		OpIndex int
	}

	inputDescriptions := [signatureRequestPropsCount]struct {
		name  string
		index int
	}{
		// msg_created_at DT_INT64 Shape:()
		{name: "signature_msg_created_at", index: 0},
		// msg_text DT_STRING Shape:()
		{name: "signature_msg_text", index: 0},
		// user_created_at DT_INT64 Shape:()
		{name: "signature_user_created_at", index: 0},
		// user_email DT_STRING Shape:()
		{name: "signature_user_email", index: 0},
	}

	for i, description := range inputDescriptions {
		op := r.graph.Operation(description.name)
		if op == nil {
			return fmt.Errorf("operation not found by name \"%s\"", description.name)
		}

		r.inputPlaceholders[i] = tf.Output{
			Op:    op,
			Index: description.index,
		}
	}

	outputDescriptions := [signatureResponsePropsCount]struct {
		name  string
		index int
	}{
		{name: "StatefulPartitionedCall", index: 0},
	}

	for i, description := range outputDescriptions {
		op := r.graph.Operation(description.name)
		if op == nil {
			return fmt.Errorf("operation not found by name \"%s\"", description.name)
		}

		r.outputPlaceholders[i] = tf.Output{
			Op:    op,
			Index: description.index,
		}
	}

	return nil
}

func (r *SignatureRunner) feedsFromRequest(req SignatureRequest) (feeds map[tf.Output]*tf.Tensor, err error) {
	feeds = make(map[tf.Output]*tf.Tensor, signatureRequestPropsCount)

	feeds[r.inputPlaceholders[0]], err = tf.NewTensor(req.MsgCreatedAt)
	if err != nil {
		return nil, fmt.Errorf("failed to create tensor for \"MsgCreatedAt\": %w", err)
	}
	feeds[r.inputPlaceholders[1]], err = tf.NewTensor(req.MsgText)
	if err != nil {
		return nil, fmt.Errorf("failed to create tensor for \"MsgText\": %w", err)
	}
	feeds[r.inputPlaceholders[2]], err = tf.NewTensor(req.UserCreatedAt)
	if err != nil {
		return nil, fmt.Errorf("failed to create tensor for \"UserCreatedAt\": %w", err)
	}
	feeds[r.inputPlaceholders[3]], err = tf.NewTensor(req.UserEmail)
	if err != nil {
		return nil, fmt.Errorf("failed to create tensor for \"UserEmail\": %w", err)
	}

	return feeds, nil
}

func (r *SignatureRunner) feedsFromTensors(tensors []*tf.Tensor) (feeds map[tf.Output]*tf.Tensor, err error) {
	if len(tensors) != signatureRequestPropsCount {
		return nil, fmt.Errorf("tensors have %d elems, %d required", len(tensors), signatureRequestPropsCount)
	}

	feeds = make(map[tf.Output]*tf.Tensor, signatureRequestPropsCount)

	for i := 0; i < signatureRequestPropsCount; i++ {
		feeds[r.inputPlaceholders[i]] = tensors[i]
	}

	return feeds, nil
}

func (r *SignatureRunner) responseFromTensors(tensors []*tf.Tensor) (SignatureResponse, error) {
	var resp SignatureResponse

	{
		val, ok := tensors[0].Value().(float32)
		if !ok {
			return SignatureResponse{}, errors.New("failed to cast tensor for \"Confidence\" to float32")
		}

		resp.Confidence = val
	}

	return resp, nil
}

func (r *SignatureRunner) Run(ctx context.Context, req SignatureRequest) (SignatureResponse, error) {
	feeds, err := r.feedsFromRequest(req)
	if err != nil {
		return SignatureResponse{}, err
	}

	fetches := r.outputPlaceholders[:]

	output, err := r.session.Run(feeds, fetches, nil)
	if err != nil {
		return SignatureResponse{}, fmt.Errorf("failed to run session: %w", err)
	}

	resp, err := r.responseFromTensors(output)
	if err != nil {
		return SignatureResponse{}, err
	}

	return resp, nil
}

func (r *SignatureRunner) RunForTensors(ctx context.Context, req SignatureRequest) ([]*tf.Tensor, error) {
	feeds, err := r.feedsFromRequest(req)
	if err != nil {
		return nil, err
	}

	fetches := r.outputPlaceholders[:]

	output, err := r.session.Run(feeds, fetches, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to run session: %w", err)
	}

	return output, nil
}

func (r *SignatureRunner) RunWithTensors(ctx context.Context, tensors []*tf.Tensor) (SignatureResponse, error) {
	feeds, err := r.feedsFromTensors(tensors)
	if err != nil {
		return SignatureResponse{}, err
	}

	fetches := r.outputPlaceholders[:]

	output, err := r.session.Run(feeds, fetches, nil)
	if err != nil {
		return SignatureResponse{}, fmt.Errorf("failed to run session: %w", err)
	}

	resp, err := r.responseFromTensors(output)
	if err != nil {
		return SignatureResponse{}, err
	}

	return resp, nil
}
